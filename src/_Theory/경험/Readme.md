## 만나본 유형 정리

    1. 배열은 정렬을 먼저하고 접근하면 편리한 경우가 많았음

```java
Arrays.sort(arr);
```

    2. 트리문제는 DFS 재귀구조로 쉽게 풀리는 경우가 많았다.

```java
    private void dfs(TreeNode node) {
        if (node == null) {
            return;
        }

        dfs(node.left);
        dfs(node.right);
    }
```

    3. 배열을 다룰 때는 투 포인터를 적극 이용하자. 단, 투 포인터는 정렬되었을 때 활용하는 경우가 많다.

    4. Greedy는 Priority Queue를 사용하는 경우가 많다.
    -> 남은 것중 가장 작은거, 가장 큰거, 가장 빠른 것 등을 순서대로 뽑아서 로직을 구성하는 경우가 많아서

    5. binary Search를 할 때는 중요한게 
    -> start + (end - start) / 2 로 중앙값을 구해야 한다.
    -> java의 Arrays.binarySearch(배열, 값) 메서드가 있다. (잇으면 위치, 없으면 앞에서부터 음수)

    6. 트리를 분할정복으로 풀어야하면 LRV 순회가 보통이었지만 그렇지 않은 경우도 있었다.

    7. Priority Queue에 생성자로 조건을 넘겨주면 다양하게 활용할 수 있다.

    8. DFS시 visited와 traced를 나누는 것이 중요하다.

    9. 스택으로 풀리는 문제가 있다.

    10. 정규식을 잘 활용해야 한다.

    11. 분할 정복을 하되 답이 여러개여서 List로 반환하는 경우가 있다.

    12. map으로 캐싱을해서 이미 탐색한것은 또다시 하지 않도록 할 수 있다.

    13. dp 혹은 greedy시 total (res) 와 current 변수를 나눠서 해결하면 1차원 배열을 써도 손쉽게 해결할 수 있는 경우가 있다.
    -> 혹은 왼쪽부터 쌓인다는 개념으로 접근하면 1차원 배열로도 손쉽게 풀리는 경우가 있다.

    14. Integer.bitCount() 를 활용하면 1 비트의 개수를 얻을 수 있다.

    15. 알파벳, 범위가 정해진 숫자의 경우는 배열로 접근해도 좋다. (0~26까지라던가)

    16. 배열을 다룰 때 슬라이딩 윈도우 방식을 활용하면 좋다. 이것은 정렬되지 않은 배열에도 사용이 가능하다.

    17. 우선순위 큐는 중복을 허용한다.

    18. StringBuilder를 사용해야 한다.

    19. bit연산시 1 << n 방식을 활용해서 masking을 할 수 있다.

    20. 2차원 배열을 다룰 때 오른쪽위, 왼쪽아래에서 시작하면 일관적인 조건으로 탐색이 가능한 경우가 있다.

    21. 시간은 숫자로 다룰 수 있도록 60을 곱하거나 해서 숫자로 만들어 비교할 수 있다.

    22. toBinaryString(), toHexString() 등을 이용해서 쉽게 변환이 가능하다.

    23. char[] 을 new String() 안에 넣으면 String을 만들 수 있다.

    24. Arrays.copyOf() 로 완전 똑같은 새로운 배열을 만들 수 있다.

    25. Math.round() * 100 / 100.0 을 이용하면 원하는 자리까지 반올림이 가능하다.